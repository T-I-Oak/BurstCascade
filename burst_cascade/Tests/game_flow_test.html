<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <title>Burst Cascade Game Flow Test</title>
    <style>
        #test-results {
            font-family: monospace;
            white-space: pre;
            border: 1px solid #ccc;
            padding: 10px;
            margin-top: 20px;
        }

        .success {
            color: green;
        }

        .failure {
            color: red;
            font-weight: bold;
        }

        canvas {
            display: none;
        }

        /* テスト中はキャンバスを隠す */
    </style>
</head>

<body>
    <h1>Burst Cascade 自動テスト (Ver 4.4.7)</h1>
    <div id="status">テスト実行中...</div>

    <!-- 必要なDOM要素の定義（main.jsが期待するもの） -->
    <canvas id="game-canvas"></canvas>
    <div id="overlay">
        <div id="mode-selection-content">
            <div id="player-select"><button class="toggle-btn selected" data-value="pvp">PVP</button></div>
            <div id="size-select"><button class="toggle-btn selected" data-value="regular">REGULAR</button></div>
            <div id="ai-level-select"><button class="toggle-btn selected" data-value="normal">NORMAL</button></div>
            <div id="ai-level-group"></div>
            <button id="game-start-btn">START</button>
        </div>
        <div id="help-content" class="hidden"></div>
        <div id="game-over-content" class="hidden">
            <h2 id="winner-text"></h2><button id="restart-btn"></button>
        </div>
    </div>
    <div id="status-container">
        <div id="p1-bar"></div>
        <div id="p2-bar"></div>
        <div id="p1-score"></div>
        <div id="p2-score"></div>
    </div>
    <span id="help-btn"></span><span id="start-help-btn"></span>
    <button id="help-close-btn"></button>
    <button class="help-back-btn"></button>
    <button id="peek-board-btn"></button>
    <div id="ai-thinking-overlay" class="hidden"></div>

    <div id="test-results"></div>

    <!-- スクリプトの読み込み -->
    <script src="../map.js"></script>
    <script src="../ai.js"></script>
    <!-- main.js は最後に読み込み、実行される -->
    <script src="../main.js"></script>

    <script>
        const results = document.getElementById('test-results');
        const log = (msg, className = '') => {
            const div = document.createElement('div');
            div.textContent = msg;
            div.className = className;
            results.appendChild(div);
            console.log(msg);
        };

        // ユーティリティ: 指定された条件が満たされるまで待機
        async function waitFor(condition, timeout = 5000) {
            const start = Date.now();
            while (!condition()) {
                if (Date.now() - start > timeout) throw new Error("待機タイムアウト");
                await new Promise(resolve => setTimeout(resolve, 100));
            }
        }

        // ユーティリティ: 演出が完全に終了してアイドル状態になるまで待機
        async function waitForIdle(game) {
            await waitFor(() => {
                return game.effects.length === 0 &&
                    game.pendingRewards.length === 0 &&
                    game.dropEffects.length === 0 &&
                    !game.isWaitingForDrop;
            }, 10000);
            // 状態が安定するまで少しだけ待つ
            await new Promise(resolve => setTimeout(resolve, 300));
        }

        async function runTests() {
            try {
                const statusEl = document.getElementById('status');
                const interval = setInterval(() => {
                    if (window.game) {
                        const g = window.game;
                        statusEl.textContent = `[DEBUG] Effects:${g.effects.length}, Rewards:${g.pendingRewards.length}, Drops:${g.dropEffects.length}, WaitingDrop:${g.isWaitingForDrop}, Lock:${g.isProcessingMove}, Current:P${g.currentPlayer}`;
                    }
                }, 100);

                log("--- テスト開始 (Ver 4.4.11) ---");

                log("1. PVCモードでの AI 二重起動チェック...");

                // モード選択を PVC に
                const pvpBtn = document.querySelector('button[data-value="pvp"]');
                const pvcBtn = document.createElement('button'); // 既存のボタンがない場合の予備
                const modeGroup = document.getElementById('player-select');

                // PVPボタンを解除してPVCを選択状態にする（実際のDOM構造に合わせる）
                // 実際には main.js が data-value を見ているのでそれをエミュレート
                const modeBtns = document.querySelectorAll('#player-select .toggle-btn');
                modeBtns.forEach(b => b.classList.remove('selected'));

                // PVCボタンを探すか作成する
                let pvcTarget = Array.from(modeBtns).find(b => b.textContent === 'PVC');
                if (!pvcTarget) {
                    pvcTarget = document.createElement('button');
                    pvcTarget.className = 'toggle-btn selected';
                    pvcTarget.setAttribute('data-value', 'pvc');
                    pvcTarget.textContent = 'PVC';
                    modeGroup.appendChild(pvcTarget);
                } else {
                    pvcTarget.classList.add('selected');
                }

                const startBtn = document.getElementById('game-start-btn');
                startBtn.click();

                const game = window.game;
                await waitFor(() => game.gameMode === 'pvc');
                log("   [OK] PVCモードで開始しました。", "success");

                log("2. P1 の行動と AI(P2) の期待される動作...");
                const targetHex = game.map.getHexAt(2, 0, 'main');
                game.handleClick({ isSimulated: true, simulatedHex: targetHex });
                log("   P1 が指しました。演出完了を待ちます...");

                // P1の演出が終わるのを待つ
                await waitForIdle(game);
                log(`   P1演出完了。現在のプレイヤー: Player ${game.currentPlayer}`);

                if (game.currentPlayer === 2) {
                    log("   [OK] P2 (AI) に手番が移りました。", "success");
                } else {
                    throw new Error("P2に手番が移っていません。");
                }

                log("3. AI の思考と「一度だけの行動」の検証...");
                // AIが思考を開始するのを待つ (setTimeout 300ms)
                await waitFor(() => game.isProcessingMove, 2000);
                log("   AI が思考・行動を開始しました。演出中の多重起動を監視します...");

                // 演出中に isProcessingMove が一度 false になる（＝ロックが解除される）不具合がないか
                // 落下中（dropEffects > 0）の間にチェックする
                let bugDetected = false;
                const checkInterval = setInterval(() => {
                    if (game.dropEffects.length > 0 && !game.isProcessingMove) {
                        bugDetected = true;
                    }
                }, 50);

                // AIの演出が完全に終わるのを待つ
                await waitForIdle(game);
                clearInterval(checkInterval);

                if (bugDetected) {
                    throw new Error("不具合検出: 落下演出中にロックが解除されました！(AI二重起動の危険)");
                } else {
                    log("   [OK] 演出中のロック解除は検出されませんでした。", "success");
                }

                log(`   AI演出完了。現在のプレイヤー: Player ${game.currentPlayer}`);
                if (game.currentPlayer === 1) {
                    log("   [OK] AIの行動が終わり、P1に手番が戻りました。", "success");
                } else {
                    // もしAIがバーストさせて報酬なしならもう一回AIの番だが、通常の初期盤面なら交代するはず
                    log(`   [INFO] 現在のプレイヤーは P${game.currentPlayer} です。連鎖状況によります。`);
                }

                log("--- すべてのテストが完了しました (ALL GREEN) ---", "success");
                statusEl.textContent = "テスト完了";
                statusEl.style.color = "green";
                clearInterval(interval);

            } catch (err) {
                log("!!! テスト失敗 !!!", "failure");
                log(err.message, "failure");
                document.getElementById('status').textContent = "テスト失敗";
                document.getElementById('status').style.color = "red";
            }
        }

        setTimeout(runTests, 500);
    </script>
</body>

</html>